import numpy as np
import random

class Genetic():
    def __init__(self, n_population, n_attributes):
        """
        Initializes a genetic algorithm object by creating the first
        population.
        
        n_population: Size of the starting population. Number of rows
        in the population matrix.
        n_attributes: Number of attributes each individual possess.
        Number of columns on the population matrix.
        
        return: Genetic object.
        """
        self.population = np.random.uniform(size=(n_population, n_attributes))
        
    def calc_fitness(self, func, *args, **kwargs):
        """
        Calculates the fitness for each subject in the population.
        
        func: The function that will be used to calculate the fitness.
        args: Arbitrary argument lists.
        kwargs: Keyword arguments.
        
        return: None.
        """
        self.fitness = np.empty(len(self.population))
        for i, subject in enumerate(self.population):
            self.fitness[i] = func(subject, *args, **kwargs)
    
    def get_fitness(self):
        """
        Getter for the fitness list.
        
        return: fitness (list).
        """
        return self.fitness
        
    def get_population(self):
        """
        Getter for the population matrix.
        
        return: population (numpy.ndarray).
        """
        return self.population
    
    def set_fitness(self, new_fitness):
        """
        Override the fitness array with a new one.
        
        new_fitness: The new fitness array that will replace the old
        one.
        
        return: None
        """
        self.fitness = new_fitness
    
    def set_population(self, new_population):
        """
        Override the population matrix with a new one.
        
        new_population: The new population that will replace the old
        one.
        
        return: None.
        """
        self.population = new_population
        
class Crossover():
    def __init__(self, probability):
        """
        Initializes a Crossover object, which is responsible for applying
        the distinct types of crossover functions.
        
        probability: The probability of ocorruing a crossover.
        
        return: Crossover object.
        """
        self.probability = probability
        
    def mean(self, population):
        """
        Apply crossover by the mean, where the children is the mean
        between the two parents. For each subject, another parents is
        chosen randomly.
        
        population: The population from which the children will be
        generated.
        
        return: new_population (numpy.ndarray). The new population after
        the crossover.
        """
        new_population = np.empty(population.shape)
        for i, subject in enumerate(population):
            r = random.random()
            if r <= self.probability:
                parent = random.choice(population)
                new_population[i] = (subject + parent)/2
            else:
                new_population[i] = subject
        return new_population
    
    def one_point(self, population):
        """
        Apply one point crossover, where a random crossover point is
        selected and the child is created by merging the head of parent
        one before that point, with the tail of parent two from that
        point.
        
        population: The population from which the children will be
        generated.
        
        return: new_population (numpy.ndarray). The new population after
        the crossover.
        """
        new_population = np.empty(population.shape)
        size = len(population[0])
        for i, subject in enumerate(population):
            r = random.random()
            if r <= self.probability:
                point = random.randrange(size)
                parent = random.choice(population)
                new_population[i][:point] = subject[:point]
                new_population[i][point:] = parent[point:]
        return new_population
        
    def uniform(self, population):
        """
        Apply a uniform crossover to the population. The children are
        generated by flipping a coin for each gene of the parents, if
        coin equals 0, the child gene comes from parent 0, otherwise it
        comes from parent 1. 
        
        population: The population from which the children will be
        generated.
        
        return: new_population (numpy.ndarray). The new population after
        the crossover.
        """
        new_population = np.empty(population.shape)
        for i, subject in enumerate(population):
            r = random.random()
            if r <= self.probability:
                parent = random.choice(population)
                for j in range(len(subject)):    
                    coin = random.randint(0, 1)
                    if coin == 0:
                        new_population[i, j] = subject[j]
                    else:
                        new_population[i, j] = parent[j]
            else:
                new_population[i] = subject
        return new_population

class Mutation():
    def __init__(self, probability):
        """
        Initializes a Mutation object, which is responsible for applying
        the distinct types of mutation functions.
        
        probability: The probability of ocorruing a mutation.
        
        return: Mutation object.
        """
        self.probability = probability
    
    #TODO Make a single func that can sum and multiply
    #TODO make a and b parameter
    def multiply_value(self, population):
        """
        Mutate the attribute of a subject by multiplying a value between
        [0.9, 1.1] to it. The mutation has a chance to occur in each
        attribute from each subject.
        
        population: The population that will suffer mutation.
        
        return: new_population (numpy.ndarray). The new population after
        the mutations.
        """
        new_population = population.copy()
        for subject in new_population:
            for i, value in enumerate(subject):
                r = random.random()
                if r <= self.probability:
                    subject[i] = value * random.uniform(0.9, 1.1)
        return new_population
        
    #TODO if attribute < 0.1 it could got to negative. Problem?
    #TODO make a and b parameter
    def sum_value(self, population):
        """
        Mutate the attribute of a subject by summing a value between
        [-0.1, 0.1] to it. The mutation has a chance to occur in each
        attribute from each subject.
        
        population: The population that will suffer mutation.
        
        return: new_population (numpy.ndarray). The new population after
        the mutations.
        """
        new_population = population.copy()
        for subject in new_population:
            for i, value in enumerate(subject):
                r = random.random()
                if r <= self.probability:
                    subject[i] = value + random.uniform(-0.1, 0.1)
        return new_population
    
    def random_resetting(self, population, a, b):
        """
        Mutate the attribute of a subject by resetting it to a random
        value in range [a, b].
        
        population: The population that will suffer mutation.
        a = start point of the random range
        b = end point of the random range
        
        return: new_population (numpy.ndarray). The new population after
        the mutations.
        """
        new_population = population.copy()
        for subject in new_population:
            for i, value in enumerate(subject):
                r = random.random()
                if r <= self.probability:
                    subject[i] = random.uniform(a, b)
        return new_population

class Selection():
    def __init__(self, n_selected):
        """
        Initializes a Selection object, which is responsible for applying
        the distinct types of selection functions.
        
        n_selected: The number of individuals that will be selected.
        
        return: Selection object.
        """
        self.n_selected = n_selected
        
    def roulette(self, fitness):
        """
        Apply a roulette wheel selection to the given population.
        
        fitness: The fitness of the individuals from the population,
        matched by the index of the list.
        
        return idx_selected (numpy.ndarray). The index for the individuals
        selected by the roulette.
        """
        probabilities = fitness/sum(fitness)
        idx_selected = np.random.choice(len(probabilities), self.n_selected,
                               p=probabilities)
        return idx_selected
    
    def n_best(self, fitness, n):
        """
        Select the n best individuals from the population.
        
        fitness: The fitness of the individuals from the population,
        matched by the index of the list.
        
        return idx_selected (numpy.ndarray). The index for the n best
        individuals.
        """
        idx_selected = np.argsort(fitness)[-n:]
        return idx_selected